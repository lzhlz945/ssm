一、<!--reset风格的url，将普通的post请求转为指定的put和delete请求-->
  <filter>
    <filter-name>hiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
  </filter>

二、spring的测试

  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration(locations = {"classpath:applicationContext.xml"})

三、批量插入

    1、    @Autowired
          private SqlSession sqlSession;

    2、EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);

    3、<bean name="sessionTemplate" class="org.mybatis.spring.SqlSessionTemplate" >
           *         <constructor-arg name="sqlSessionFactory" ref="factory"/>
           *         <constructor-arg name="executorType" value="BATCH"/>
           *     </bean>



四、mvc MockMvc模拟测试

    1、导入注解@WebAppConfiguration

    2、定义MockMVC和注入mvc容器
          @Autowired
          private WebApplicationContext context;
          MockMvc mockMvc;

    3、在测试前获取MockMvc
       @Before
           public void initMockMvc(){
               mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
           }

    4、测试+从request域对象中取出数据
        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get("/emps").param("pn","1")).andReturn();
               MockHttpServletRequest request = result.getRequest();



五、getContextPath

    pageContext.setAttribute("PATH",request.getContextPath());
    /*
    * request.getContextPath()以/开头，不已/结束
    * */


    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <%
        String basePath = request.getScheme()
                + "://"
                + request.getServerName()
                + ":"
                + request.getServerPort()
                + request.getContextPath()
                + "/";
        pageContext.setAttribute("basePath",basePath);
    %>

    <!--写base标签，永远固定相对路径跳转的结果-->
    <base href="<%=basePath%>">

     <%@ include file="/pages/common/head.jsp"%>


六、添加通用返回
     1、私有code,message,map
     2、get\set方法
     3、写static success fail 写返回的map


七、				//var html1 = "'\"\"'";
  				//var html2 = '"\'\'"';


八、全选反选
              $("#tBodyBtn").on("click",$("input[name=xz]"),function () {
                             $("#qx").prop("checked",$("input[name=xz]").length==$("input[name=xz]:checked").length)
                         })

                         $("#qx").click(function () {
                             $("input[name=xz]").prop("checked",this.checked);
                         })



            以上事件没有触发，是因为绑定事件的元素，是通过js代码手动拼接生成的，这种元素，也叫做动态生成的元素
   			动态生成的元素，不能以传统的方式来绑定事件$("input[name=xz]").click(function ()
   			将来我们会大量的遇到这种需求，也就是为动态生成的元素绑定事件，我们要通过on的方式来对这些元素进行绑定

   			语法：
   				$(需要绑定的元素的有效的父级元素).on(绑定事件的方式，需要绑定的元素，回调函数)


   			我们现在需要绑定的元素是所有name=xz的input，我们找到后，看到了他（们）的父级元素td
   			td虽然是父级，但是td是无效的父级元素（如果父级元素仍然是动态拼接生成的，即定义为无效）
   			如果无效，继续向该父级的元素继续向上寻找，最终我们找到了tBody元素